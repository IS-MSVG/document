## 节点负载计算
### CPU 负载计算
- cpu load
  - cpu 负载上升随着CPU整体占用率上升存在阶段式变化，如图表所示。

    |CPU负载|每秒完成事件数|P95时延|
    |-|-|-|
    |5%|5018.88|1.55|
    |10%|4821.02|1.61|
    |15%|4747.02|1.64|
    |20%|4064.58|4.33|
    |25%|4434.73|4.41|
    |30%|4251.46|5.37|
    |35%|4002.32|5.88|
    |40%|3926.96|6.67|
    |45%|3797.07|7.3|
    |50%|3596.93|7.98|
    |55%|3365.69|8.9|
    |60%|3460.48|9.28|
    |65%|3360.38|10.27|
    |70%|3281.72|11.45|
    |75%|3262.01|10.27|
    |80%|2783.31|12.52|
    |85%|3033.27|12.3|
    |90%|2665.2|13.46|
    |95%|2631.41|12.46|

  - 分析表中数据
    - 发现`CPU占用率`达到20%时，`P95时延`会有一个大幅上升，推断此时CPU性能有一个急速下降的表现，由`每秒完成事件数`也可以看到20%时`每秒完成事件数`有一个明显的下降趋势，可以表明在20%`CPU负载`时CPU性能表现进入新的变化阶段，此前由`P95时延`可以看出20%之前是一个基本平稳的表现区间
    - 在`CPU占用率`达到70%之前，`每秒完成事件数`与`P95时延`处于一个稳定变化的阶段，随着`CPU`占用率的增加，`每秒完成事件数`逐步下降 `P95时延`逐步上升，呈线性变化规律。
    - 当`CPU占用率`达到70%之后，`每秒完成事件数`与`P95时延`出现剧烈波动情况，此时CPU性能表现不稳定，说明CPU负载值到达一个高负载的状态，应该做的是减少任务的分配，因为此时应用不一定能够提供完全稳定的服务。
### memory 负载计算
- CPU load
  - memory 性能表现会受到 CPU 负载的影响，因为memory相关的复制修改迁移等操作也是需要 CPU 的参与，所以CPU负载的高低也会影响 memory的性能表现

    |CPU 占用率|完成memory任务时间|
    |-|-|
    |5%|4.8841|
    |10%|5.1356|
    |15%|5.3168|
    |20%|5.5886|
    |25%|5.7420|
    |30%|6.1722|
    |35%|6.7806|
    |40%|7.3560|
    |45%|7.3162|
    |50%|7.9633|
    |55%|8.2633|
    |60%|8.5374|
    |65%|9.1961|
    |70%|9.6788|
    |75%|9.2272|
    |80%|9.6300|
    |85%|10.2440|
    |90%|10.3746|
    |95%|10.7249|

  - 分析表中数据，发现随着`CPU占用率`的升高，对于内存相关的应用，它的性能表现会逐步降低，可以看出`CPU负载`对于内存应用的性能表现存在一定的影响，大致呈线性的影响。
- memory load
  - memory 本身负载对对于应用性能的表现体现在应用对于内存资源的需求是否超出了当前的余量内存，如果超过了当前的余量内存，那么应用性能就会急速变差，不超过内存时，每次任务申请的内存量越大需要的响应时间就越久

    |内存占用量/总量|单次内存申请量/总申请量|完成任务耗时|特殊说明|
    |-|-|-|-|
    |4G/8G|4 * 1M/100G|4.0908s||
    |4G/8G|4 * 4M/100G|6.1031s||
    |4G/8G|4 * 8M/100G|8.0636s||
    |4G/8G|4 * 512M/100G|17.4046s||
    |4G/8G|4 * 1G/100G|19.0986s||
    |4G/8G|4 * 2G/100G|21.4321s|此时会存在stop the world 问题，对于应用来讲是非常致命的|

  - 分析表中的数据，可以得出内存应用性能表现的影响因素在于请求的内存量，涉及到内存分配以及系统缓存带来的换入换出的影响因素，随着所需内存的增加，缓存的换入换出也会变得频繁，这些也影响了应用的性能表现。所以负载的依据应该与应用申请的内存以及系统本身的缓存大小存在关系；当内存申请大于所剩内存时，会发生磁盘内容与内存交换的情况，负载会急剧上升。

### 磁盘负载 (观测指标，文件写入读取速度)
- CPU load
  - 磁盘性能表现会受到CPU负载的影响，需要CPU搬运数据写入内存，然后同步至磁盘，都需要CPU的参与。

    |CPU 存在IO线程数|read 速率 M/s|write 速率 M/s|
    |-|-|-|
    |0|126|54.2|
    |1|40.1|17.2|
    |2|39.8|17.0|
    |3|39.4|17.1|
    |4|39.9|17.2|

  - 分析表中数据，结合操作系统对于IO线程的调用方式，得出磁盘IO在CPU一直存在IO任务时，裁判处于一个高负载的状态，是没有写入负载时的1/3左右。分析这个和`CPU负载`中关于io时间的部分有着密切的联系，`系统IO负载`和CPU分给IO的调度时间有着绝对的关系。

### 计算公式
#### CPU 计算
- CPU计算考虑三段式计算，由分析可以得出CPU存在不同的性能表现变化区间，有数据分析变化区间应该是[0, 20]， [20, 70]， [70, 100]
- 计算公式为(后续会根据集群具体性能表现修改)
  - 参数说明:
    - CPU 负载计算值: $Load_{cpu}$ ；
    - CPU占用率: $X_{cpu}$；
  - $ Load_{cpu} = 1, \ \ X_{cpu} \ \ in \ \ [0, 20] $ 
  - $ Load_{cpu} = 0.3 * X_{cpu} - 5, \ \ X_{cpu} \ \ in \ \ [30, 70] $
  - $ Load_{cpu} = 5 * e^{(\frac{1}{10}(X_{cpu}-70))} + 8, \ \ X_{cpu} \ \ in \ \ [70, 100]$
#### memory 计算
- memory 计算需要考虑两个因素，一个是CPU负载，一个是内存负载，对于 memory 来说，CPU负载总体对性能表现呈线性影响趋势，综合两张表来看，内存负载对于性能的影响更大
- 计算公式(后续会根据集群具体性能表现修改)
  - 参数说明: 
    - memory 负载计算值: $Load_{mem}$；
    - memory 占用率: $X_{mem}$；
    - CPU 对 memory 负载影响计算值: $Load_{CPU}$；
    - CPU 占用率: $X_{CPU}$
  - $ Load_{mem} = X_{mem}, \ \ X_{mem} \ \ in \ \ [0, 100] $
  - $ Load_{CPU} = X_{CPU}, \ \ X_{CPU} \ \ in \ \ [0, 100] $
  - $ Load_{mem} = Load_{mem} * 0.65 + Load_{cpu} * 0.35 $
#### 磁盘计算
- 磁盘负载计算也是主要考虑CPU负载和磁盘本身IOPS情况，CPU负载总体对磁盘性能表现呈线性影响趋势，IOPS也为线性影响趋势，磁盘负载主要影响数据存储这种服务的性能。总体上CPU对磁盘性能表现的影响大于磁盘IOPS对性能的影响。
- 计算公式(后续会根据集群具体性能表现修改)
  - 参数说明:
    - 磁盘负载计算值: $Load_{io}$
    - 磁盘占用率: $X_{io}$
    - CPU 对磁盘负载影响计算值: $Load_{CPU}$
    - CPU 占用率: $X_{CPU}$
  - $ Load_{io} = X_{io}, \ \ X_{io} \ \ in \ \ [0, 100] $
  - $ Load_{CPU} = X_{CPU}, \ \ X_{CPU} \ \ in \ \ [0, 100] $
  - $ Load_{mem} = Load_{io} * 0.35 + Load_{cpu} * 0.65 $

## 实例负载
### CPU 负载
- 参考平台负载中CPU负载计算与分析，在后续实际测试中再做调整
### memory 负载
- 参考平台负载中CPU负载计算与分析，在后续实际测试中再做调整
### API 负载
#### API 响应时间
- API 响应时间作为负载的一部分，目前按照响应时间的变化作为负载值的考虑依据，当API响应时间持续增加时，认为处于高负载，当API响应时间稳定是，认为处于负载均衡的状态。
- 服务响应 web 一般收敛在200ms内，高于5s为无法忍受的响应时间
#### API 响应状态
- API 响应状态主要关注20x, 40x, 50x。
  - 20x 代表请求被正确响应，表示目前实例可以正确提供服务。
  - 40x 代表请求访问出现问题，一般是服务不存在404或者是请求信息出错400，这个分情况处理
  - 50x 代表请求没有被正确响应，表示目前实例内部请求处理存在问题，需要重点处理
- 对于 API 响应状态，20x 和 400 都是正常的请求响应，而 404 与 50x 都是异常的请求响应。当异常响应的占比达到3%以上时认为当前服务实例不能正常响应请求。

### 计算公式
#### API 响应时间
- 参数说明：
  - API 响应时间负载值 Load_{API_RESPONSE_TIME}
  - API 响应时间一定时间区间变化趋势(变化系数) X_{API_TIME}，大于10时认为处于不可用状态
- $ Load_{API_RESPONSE_TIME} =  X_{API_TIME} * 10, \ \ X_{API_TIME} \ \ in \ \ [0, 20] $
#### API 响应状态
- 参数说明：
  - API 响应状态负载值 Load_{API_STATUS}
  - API 错误响应状态占比 X_{API_ERR} = count(err) / count(status) * 100
- $ Load_{API_STATUS} = X_{API_ERR} * 33, \ \ X_{API_ERR} \ \ in \ \ [0, 3] $

## 总体负载
- 需要将节点负载与实力负载相结合